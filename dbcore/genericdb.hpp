/* Generated by eXtremeDB Schema Compiler, build 1797, rev. stable, rev. 23320
 * at Mon Dec 31 21:26:05 2018
 */

#ifndef __MCO__genericdb__HPP__
#define __MCO__genericdb__HPP__

#include "mco.hpp"

#define MCO_CPP_INTERFACE
#include "genericdb.h"

namespace genericdb
{

class McoBase_
{
  protected:
  MCO_Hf h_;
  bool    valid_;
  McoBase_() : valid_(false) {} 
  McoBase_(McoBase_ const& other) : valid_(other.valid_) { mco_assign_handle(&h_, &other.h_); } 
  public:
  bool is_valid() const  { return valid_; }
  void set_valid(bool v) { valid_ = v; }
};






class A : public McoBase_
{
  public:

  MCO_RET create( mco_trans_h t );
  MCO_RET remove();
  MCO_RET remove_all( mco_trans_h t );
  MCO_RET checkpoint();
  MCO_RET ui4_get( uint4 & result );
  struct { 
    A* handle_;
    operator  uint4() const {
      uint4 val_;
      MCO_CPP_CHECK(A_ui4_get(handle_, &val_));
      return val_;
    }
    uint4 operator=(uint4 val_) {
      MCO_CPP_CHECK(A_ui4_put(handle_, val_));
      return val_;
    }
  } ui4;

  MCO_RET ui4_put( uint4 value );
  A() {
    ui4.handle_ = this;
  }

  MCO_RET from_cursor( mco_trans_h t, mco_cursor_h c );
  static MCO_RET list_cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c );
};

class B : public McoBase_
{
  public:

  MCO_RET create( mco_trans_h t );
  MCO_RET remove();
  MCO_RET set_allocation_block_size(mco_trans_h t, mco_size_t block_size);
  MCO_RET set_caching_priority(mco_trans_h t, int priority);
  MCO_RET remove_all( mco_trans_h t );
  MCO_RET checkpoint();
  MCO_RET ui4_get( uint4 & result );
  struct { 
    B* handle_;
    operator  uint4() const {
      uint4 val_;
      MCO_CPP_CHECK(B_ui4_get(handle_, &val_));
      return val_;
    }
    uint4 operator=(uint4 val_) {
      MCO_CPP_CHECK(B_ui4_put(handle_, val_));
      return val_;
    }
  } ui4;

  MCO_RET ui4_put( uint4 value );
  B() {
    ui4.handle_ = this;
  }

  MCO_RET from_cursor( mco_trans_h t, mco_cursor_h c );
  static MCO_RET list_cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c );
};

class Part : public McoBase_
{
  public:

  MCO_RET create( mco_trans_h t );
  MCO_RET remove();
  MCO_RET remove_all( mco_trans_h t );
  MCO_RET checkpoint();
  MCO_RET type_get( char * dest, uint2 dest_size, uint2 & len);
  MCO_RET type_size(uint2 &result);
  struct { 
    Part* handle_;
    operator std::string() const {
      std::string str_;
      uint2 len_;
      MCO_CPP_CHECK(Part_type_size(handle_, &len_));
      str_.resize(len_);
      MCO_CPP_CHECK(Part_type_get(handle_, &str_[0], len_, &len_));
      return str_;
    }
    std::string const& operator=(std::string const& str_) {
      MCO_CPP_CHECK(Part_type_put(handle_, str_.data(), str_.size()));
      return str_;
    }
  } type;

  MCO_RET type_put(const char * src, uint2 len);
  MCO_RET name_get( char * dest, uint2 dest_size, uint2 & len);
  MCO_RET name_size(uint2 &result);
  struct { 
    Part* handle_;
    operator std::string() const {
      std::string str_;
      uint2 len_;
      MCO_CPP_CHECK(Part_name_size(handle_, &len_));
      str_.resize(len_);
      MCO_CPP_CHECK(Part_name_get(handle_, &str_[0], len_, &len_));
      return str_;
    }
    std::string const& operator=(std::string const& str_) {
      MCO_CPP_CHECK(Part_name_put(handle_, str_.data(), str_.size()));
      return str_;
    }
  } name;

  MCO_RET name_put(const char * src, uint2 len);
  MCO_RET price_get( float & result );
  struct { 
    Part* handle_;
    operator  float() const {
      float val_;
      MCO_CPP_CHECK(Part_price_get(handle_, &val_));
      return val_;
    }
    float operator=(float val_) {
      MCO_CPP_CHECK(Part_price_put(handle_, val_));
      return val_;
    }
  } price;

  MCO_RET price_put( float value );
  MCO_RET code_get( uint4 & result );
  struct { 
    Part* handle_;
    operator  uint4() const {
      uint4 val_;
      MCO_CPP_CHECK(Part_code_get(handle_, &val_));
      return val_;
    }
    uint4 operator=(uint4 val_) {
      MCO_CPP_CHECK(Part_code_put(handle_, val_));
      return val_;
    }
  } code;

  MCO_RET code_put( uint4 value );
  MCO_RET dim_read( Dimensions & s );
  MCO_RET dim_write( Dimensions & s );
  MCO_RET options_at(uint2 index, uint4 &result);
  MCO_RET options_get_range(uint2 start_index, uint2 num, uint4 *dest );
  struct { 
    Part* handle_;
    operator std::vector<uint4>() const {
      std::vector<uint4> arr_(10);
      MCO_CPP_CHECK(Part_options_get_range(handle_, 0, 10, (uint4*)&arr_[0]));
      return arr_;
    }
    std::vector<uint4> const& operator=(std::vector<uint4> const& arr_) {
      MCO_CPP_CHECK(Part_options_put_range(handle_, 0, (uint2)arr_.size(), (uint4*)&arr_[0]));
      return arr_;
    }
  } options;

  MCO_RET options_put(uint2 index, uint4 value );
  MCO_RET options_put_range(uint2 start_index, uint2 num, const uint4 * src );
  Part() {
    type.handle_ = this;
    name.handle_ = this;
    price.handle_ = this;
    code.handle_ = this;
    options.handle_ = this;
  }

  MCO_RET from_cursor( mco_trans_h t, mco_cursor_h c );

  class ByCode // hash index
  { public: 
    static MCO_RET cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c );
    static MCO_RET compare( mco_trans_h t_, mco_cursor_h c_, uint4 code_key_, int & result_ ); 
    static MCO_RET find( mco_trans_h t_, uint4 code_key_, /*OUT*/ Part & handle_); 
  }; // ByCode

  class ByType // b-tree index
  { public: 
    static MCO_RET cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c );
    static MCO_RET search( mco_trans_h t_, mco_cursor_h c_, MCO_OPCODE op_, const char *type_key_, uint2 sizeof_type_key_, const char *name_key_, uint2 sizeof_name_key_ ); 
    static MCO_RET compare( mco_trans_h t_, mco_cursor_h c_, const char *type_key_, uint2 sizeof_type_key_, const char *name_key_, uint2 sizeof_name_key_, int & result_ ); 
    static MCO_RET pattern_size( const char *type_key_, uint2 sizeof_type_key_, const char *name_key_, uint2 sizeof_name_key_, /*OUT*/ uint4 *size_); 
    static MCO_RET pattern_search  ( mco_trans_h t, mco_cursor_h c, /*INOUT*/ void *allocated_pattern, mco_size_t memsize , const char *type_key_, uint2 sizeof_type_key_, const char *name_key_, uint2 sizeof_name_key_); 
    static MCO_RET pattern_next  ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern ); 
    static MCO_RET locate(mco_trans_h t, /*OUT*/ mco_cursor_h c, Part & handle);
  }; // ByType

  class IdxCode // b-tree index
  { public: 
    static MCO_RET cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c );
    static MCO_RET search( mco_trans_h t_, mco_cursor_h c_, MCO_OPCODE op_, uint4 code_key_ ); 
    static MCO_RET compare( mco_trans_h t_, mco_cursor_h c_, uint4 code_key_, int & result_ ); 
    static MCO_RET pattern_size( uint4 code_key_, /*OUT*/ uint4 *size_); 
    static MCO_RET pattern_search  ( mco_trans_h t, mco_cursor_h c, /*INOUT*/ void *allocated_pattern, mco_size_t memsize , uint4 code_key_); 
    static MCO_RET pattern_next  ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern ); 
    static MCO_RET locate(mco_trans_h t, /*OUT*/ mco_cursor_h c, Part & handle);
    static MCO_RET find( mco_trans_h t_, uint4 code_key_, /*OUT*/ Part & handle_); 
  }; // IdxCode
};

class Part2 : public McoBase_
{
  public:

  MCO_RET create( mco_trans_h t );
  MCO_RET remove();
  MCO_RET remove_all( mco_trans_h t );
  MCO_RET checkpoint();
  MCO_RET broker_id_get( int4 & result );
  struct { 
    Part2* handle_;
    operator  int4() const {
      int4 val_;
      MCO_CPP_CHECK(Part2_broker_id_get(handle_, &val_));
      return val_;
    }
    int4 operator=(int4 val_) {
      MCO_CPP_CHECK(Part2_broker_id_put(handle_, val_));
      return val_;
    }
  } broker_id;

  MCO_RET broker_id_put( int4 value );
  struct { 
    Part2* handle_;
    operator std::string() const {
      std::string str_(8, '\0');
      MCO_CPP_CHECK(Part2_password_get(handle_, &str_[0], 8));
      return str_;
    }
    operator Char<8>() const {
      Char<8> chars_;
      MCO_CPP_CHECK(Part2_password_get(handle_, chars_.body, 8));
      return chars_;
    }
    std::string const& operator=(std::string const& str_) {
      MCO_CPP_CHECK(Part2_password_put(handle_, str_.data(), str_.size()));
      return str_;
    }
    Char<8> const& operator=(Char<8> const& str_) {
      MCO_CPP_CHECK(Part2_password_put(handle_, str_.body, 8));
      return str_;
    }
  } password;

  MCO_RET password_get(char * dest, uint2 dest_size);
  MCO_RET password_put( const char * src, uint2 len );
  MCO_RET user_id_get( uint4 & result );
  struct { 
    Part2* handle_;
    operator  uint4() const {
      uint4 val_;
      MCO_CPP_CHECK(Part2_user_id_get(handle_, &val_));
      return val_;
    }
    uint4 operator=(uint4 val_) {
      MCO_CPP_CHECK(Part2_user_id_put(handle_, val_));
      return val_;
    }
  } user_id;

  MCO_RET user_id_put( uint4 value );
  Part2() {
    broker_id.handle_ = this;
    password.handle_ = this;
    user_id.handle_ = this;
  }

  MCO_RET from_cursor( mco_trans_h t, mco_cursor_h c );

  class IdxCode // b-tree index
  { public: 
    static MCO_RET cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c );
    static MCO_RET search( mco_trans_h t_, mco_cursor_h c_, MCO_OPCODE op_, uint4 user_id_key_ ); 
    static MCO_RET compare( mco_trans_h t_, mco_cursor_h c_, uint4 user_id_key_, int & result_ ); 
    static MCO_RET pattern_size( uint4 user_id_key_, /*OUT*/ uint4 *size_); 
    static MCO_RET pattern_search  ( mco_trans_h t, mco_cursor_h c, /*INOUT*/ void *allocated_pattern, mco_size_t memsize , uint4 user_id_key_); 
    static MCO_RET pattern_next  ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern ); 
    static MCO_RET locate(mco_trans_h t, /*OUT*/ mco_cursor_h c, Part2 & handle);
    static MCO_RET find( mco_trans_h t_, uint4 user_id_key_, /*OUT*/ Part2 & handle_); 
  }; // IdxCode
};

class User : public McoBase_
{
  public:

  MCO_RET create( mco_trans_h t );
  MCO_RET remove();
  MCO_RET remove_all( mco_trans_h t );
  MCO_RET checkpoint();
  MCO_RET broker_id_get( int4 & result );
  struct { 
    User* handle_;
    operator  int4() const {
      int4 val_;
      MCO_CPP_CHECK(User_broker_id_get(handle_, &val_));
      return val_;
    }
    int4 operator=(int4 val_) {
      MCO_CPP_CHECK(User_broker_id_put(handle_, val_));
      return val_;
    }
  } broker_id;

  MCO_RET broker_id_put( int4 value );
  MCO_RET user_id_get( uint4 & result );
  struct { 
    User* handle_;
    operator  uint4() const {
      uint4 val_;
      MCO_CPP_CHECK(User_user_id_get(handle_, &val_));
      return val_;
    }
    uint4 operator=(uint4 val_) {
      MCO_CPP_CHECK(User_user_id_put(handle_, val_));
      return val_;
    }
  } user_id;

  MCO_RET user_id_put( uint4 value );
  struct { 
    User* handle_;
    operator std::string() const {
      std::string str_(8, '\0');
      MCO_CPP_CHECK(User_password_get(handle_, &str_[0], 8));
      return str_;
    }
    operator Char<8>() const {
      Char<8> chars_;
      MCO_CPP_CHECK(User_password_get(handle_, chars_.body, 8));
      return chars_;
    }
    std::string const& operator=(std::string const& str_) {
      MCO_CPP_CHECK(User_password_put(handle_, str_.data(), str_.size()));
      return str_;
    }
    Char<8> const& operator=(Char<8> const& str_) {
      MCO_CPP_CHECK(User_password_put(handle_, str_.body, 8));
      return str_;
    }
  } password;

  MCO_RET password_get(char * dest, uint2 dest_size);
  MCO_RET password_put( const char * src, uint2 len );
  User() {
    broker_id.handle_ = this;
    user_id.handle_ = this;
    password.handle_ = this;
  }

  MCO_RET from_cursor( mco_trans_h t, mco_cursor_h c );

  class idx_user_id // b-tree index
  { public: 
    static MCO_RET cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c );
    static MCO_RET search( mco_trans_h t_, mco_cursor_h c_, MCO_OPCODE op_, uint4 user_id_key_ ); 
    static MCO_RET compare( mco_trans_h t_, mco_cursor_h c_, uint4 user_id_key_, int & result_ ); 
    static MCO_RET pattern_size( uint4 user_id_key_, /*OUT*/ uint4 *size_); 
    static MCO_RET pattern_search  ( mco_trans_h t, mco_cursor_h c, /*INOUT*/ void *allocated_pattern, mco_size_t memsize , uint4 user_id_key_); 
    static MCO_RET pattern_next  ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern ); 
    static MCO_RET locate(mco_trans_h t, /*OUT*/ mco_cursor_h c, User & handle);
    static MCO_RET find( mco_trans_h t_, uint4 user_id_key_, /*OUT*/ User & handle_); 
  }; // idx_user_id
};

struct Dimensions : public McoBase_
{
  public:

  MCO_RET width_get( float & result );
  struct { 
    Dimensions* handle_;
    operator  float() const {
      float val_;
      MCO_CPP_CHECK(Dimensions_width_get(handle_, &val_));
      return val_;
    }
    float operator=(float val_) {
      MCO_CPP_CHECK(Dimensions_width_put(handle_, val_));
      return val_;
    }
  } width;

  MCO_RET width_put( float value );
  MCO_RET length_get( float & result );
  struct { 
    Dimensions* handle_;
    operator  float() const {
      float val_;
      MCO_CPP_CHECK(Dimensions_length_get(handle_, &val_));
      return val_;
    }
    float operator=(float val_) {
      MCO_CPP_CHECK(Dimensions_length_put(handle_, val_));
      return val_;
    }
  } length;

  MCO_RET length_put( float value );
  MCO_RET height_get( float & result );
  struct { 
    Dimensions* handle_;
    operator  float() const {
      float val_;
      MCO_CPP_CHECK(Dimensions_height_get(handle_, &val_));
      return val_;
    }
    float operator=(float val_) {
      MCO_CPP_CHECK(Dimensions_height_put(handle_, val_));
      return val_;
    }
  } height;

  MCO_RET height_put( float value );
  Dimensions() {
    width.handle_ = this;
    length.handle_ = this;
    height.handle_ = this;
  }

}; // Dimensions

inline  MCO_RET A::create( mco_trans_h t )
{ MCO_RET ret_ = genericdb::A_new(t,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET A::remove()
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::A_delete(this)); 
}

inline  MCO_RET A::remove_all( mco_trans_h t )
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::A_delete_all(t)); 
}

inline  MCO_RET A::checkpoint()
{ MCO_RET ret_=genericdb::A_checkpoint(this); return ret_;
}

inline  MCO_RET A::ui4_get ( uint4 & result )
{ MCO_RET ret_ = genericdb::A_ui4_get(this, &result); return ret_;
} 

inline  MCO_RET A::ui4_put( uint4 value )
{ MCO_RET ret_ = genericdb::A_ui4_put(this, value); return ret_; 
} 

inline  MCO_RET A::from_cursor( mco_trans_h t, mco_cursor_h c )
{ MCO_RET ret_ = genericdb::A_from_cursor(t,c,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET A::list_cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c )
{ return genericdb::A_list_cursor(t,c); 
} 

inline  MCO_RET B::create( mco_trans_h t )
{ MCO_RET ret_ = genericdb::B_new(t,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET B::remove()
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::B_delete(this)); 
}

inline  MCO_RET B::set_allocation_block_size(mco_trans_h t, mco_size_t block_size)
{ return genericdb::B_set_allocation_block_size(t, block_size); 
}

inline  MCO_RET B::set_caching_priority(mco_trans_h t, int priority)
{ return genericdb::B_set_caching_priority(t, priority); 
}

inline  MCO_RET B::remove_all( mco_trans_h t )
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::B_delete_all(t)); 
}

inline  MCO_RET B::checkpoint()
{ MCO_RET ret_=genericdb::B_checkpoint(this); return ret_;
}

inline  MCO_RET B::ui4_get ( uint4 & result )
{ MCO_RET ret_ = genericdb::B_ui4_get(this, &result); return ret_;
} 

inline  MCO_RET B::ui4_put( uint4 value )
{ MCO_RET ret_ = genericdb::B_ui4_put(this, value); return ret_; 
} 

inline  MCO_RET B::from_cursor( mco_trans_h t, mco_cursor_h c )
{ MCO_RET ret_ = genericdb::B_from_cursor(t,c,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET B::list_cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c )
{ return genericdb::B_list_cursor(t,c); 
} 

inline  MCO_RET Part::create( mco_trans_h t )
{ MCO_RET ret_ = genericdb::Part_new(t,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET Part::remove()
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::Part_delete(this)); 
}

inline  MCO_RET Part::remove_all( mco_trans_h t )
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::Part_delete_all(t)); 
}

inline  MCO_RET Part::checkpoint()
{ MCO_RET ret_=genericdb::Part_checkpoint(this); return ret_;
}

inline  MCO_RET Part::type_get( char * dest, uint2 dest_size, uint2 & len)
{ MCO_RET ret_ = genericdb::Part_type_get(this, dest, dest_size, &len); return ret_; 
}

inline  MCO_RET Part::type_size(uint2 &result)
{ MCO_RET ret_ = genericdb::Part_type_size(this, &result); return ret_;
}

inline  MCO_RET Part::type_put(const char * src, uint2 len)
{ MCO_RET ret_ = genericdb::Part_type_put(this,src,len); return ret_; 
} 

inline  MCO_RET Part::name_get( char * dest, uint2 dest_size, uint2 & len)
{ MCO_RET ret_ = genericdb::Part_name_get(this, dest, dest_size, &len); return ret_; 
}

inline  MCO_RET Part::name_size(uint2 &result)
{ MCO_RET ret_ = genericdb::Part_name_size(this, &result); return ret_;
}

inline  MCO_RET Part::name_put(const char * src, uint2 len)
{ MCO_RET ret_ = genericdb::Part_name_put(this,src,len); return ret_; 
} 

inline  MCO_RET Part::price_get ( float & result )
{ MCO_RET ret_ = genericdb::Part_price_get(this, &result); return ret_;
} 

inline  MCO_RET Part::price_put( float value )
{ MCO_RET ret_ = genericdb::Part_price_put(this, value); return ret_; 
} 

inline  MCO_RET Part::code_get ( uint4 & result )
{ MCO_RET ret_ = genericdb::Part_code_get(this, &result); return ret_;
} 

inline  MCO_RET Part::code_put( uint4 value )
{ MCO_RET ret_ = genericdb::Part_code_put(this, value); return ret_; 
} 

inline  MCO_RET Part::dim_read( Dimensions & s )
{ MCO_RET ret_ = genericdb::Part_dim_read_handle(this, &s ); s.set_valid(ret_==MCO_S_OK); return ret_; 
} 

inline  MCO_RET Part::dim_write( Dimensions & s )
{ MCO_RET ret_ = genericdb::Part_dim_write_handle(this, &s ); s.set_valid(ret_==MCO_S_OK); return ret_; 
} 

inline  MCO_RET Part::options_at(uint2 index, uint4 &result)
{ MCO_RET ret_ = genericdb::Part_options_at(this, index, &result); return ret_;
}

inline  MCO_RET Part::options_get_range(uint2 start_index, uint2 num, uint4 *dest )
{ MCO_RET ret_ = genericdb::Part_options_get_range(this, start_index, num, dest); return ret_; 
}

inline  MCO_RET Part::options_put(uint2 index, uint4 value )
{ MCO_RET ret_ = genericdb::Part_options_put(this, index, value); return ret_;
}

inline  MCO_RET Part::options_put_range(uint2 start_index, uint2 num, const uint4 * src )
{ MCO_RET ret_ = genericdb::Part_options_put_range(this, start_index, num, src); return ret_; 
}

inline  MCO_RET Part::from_cursor( mco_trans_h t, mco_cursor_h c )
{ MCO_RET ret_ = genericdb::Part_from_cursor(t,c,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET Part::ByCode::cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c )
{ return genericdb::Part_ByCode_index_cursor(t,c); 
}

inline  MCO_RET Part::ByCode::compare( mco_trans_h t_, mco_cursor_h c_, uint4 code_key_, int & result_ ) 
{ return genericdb::Part_ByCode_compare(t_,c_, code_key_, &result_); 
}

inline  MCO_RET Part::ByCode::find( mco_trans_h t_, uint4 code_key_, /*OUT*/ Part & handle_) 
{ MCO_RET ret_ = genericdb::Part_ByCode_find(t_, code_key_, &handle_ ); handle_.set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET Part::ByType::cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c )
{ return genericdb::Part_ByType_index_cursor(t,c); 
}

inline  MCO_RET Part::ByType::search( mco_trans_h t_, mco_cursor_h c_, MCO_OPCODE op_, const char *type_key_, uint2 sizeof_type_key_, const char *name_key_, uint2 sizeof_name_key_ ) 
{ return genericdb::Part_ByType_search(t_,c_,op_, type_key_, sizeof_type_key_, name_key_, sizeof_name_key_); 
}

inline  MCO_RET Part::ByType::compare( mco_trans_h t_, mco_cursor_h c_, const char *type_key_, uint2 sizeof_type_key_, const char *name_key_, uint2 sizeof_name_key_, int & result_ ) 
{ return genericdb::Part_ByType_compare(t_,c_, type_key_, sizeof_type_key_, name_key_, sizeof_name_key_, &result_); 
}

inline  MCO_RET Part::ByType::pattern_size( const char *type_key_, uint2 sizeof_type_key_, const char *name_key_, uint2 sizeof_name_key_, /*OUT*/ uint4 *size_) 
{ return genericdb::Part_ByType_pattern_size( type_key_, sizeof_type_key_, name_key_, sizeof_name_key_, size_); 
}

inline  MCO_RET Part::ByType::pattern_search ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern, mco_size_t memsize , const char *type_key_, uint2 sizeof_type_key_, const char *name_key_, uint2 sizeof_name_key_)
{ return genericdb::Part_ByType_pattern_search (t,c, allocated_pattern, memsize, type_key_, sizeof_type_key_, name_key_, sizeof_name_key_); 
}

inline  MCO_RET Part::ByType::pattern_next ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern )
{ return genericdb::Part_ByType_pattern_next (t, c, allocated_pattern); 
}

inline  MCO_RET Part::ByType::locate(mco_trans_h t, /*OUT*/ mco_cursor_h c, Part & handle)
{ return genericdb::Part_ByType_locate(t, c, &handle ); 
}

inline  MCO_RET Part::IdxCode::cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c )
{ return genericdb::Part_IdxCode_index_cursor(t,c); 
}

inline  MCO_RET Part::IdxCode::search( mco_trans_h t_, mco_cursor_h c_, MCO_OPCODE op_, uint4 code_key_ ) 
{ return genericdb::Part_IdxCode_search(t_,c_,op_, code_key_); 
}

inline  MCO_RET Part::IdxCode::compare( mco_trans_h t_, mco_cursor_h c_, uint4 code_key_, int & result_ ) 
{ return genericdb::Part_IdxCode_compare(t_,c_, code_key_, &result_); 
}

inline  MCO_RET Part::IdxCode::pattern_size( uint4 code_key_, /*OUT*/ uint4 *size_) 
{ return genericdb::Part_IdxCode_pattern_size( code_key_, size_); 
}

inline  MCO_RET Part::IdxCode::pattern_search ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern, mco_size_t memsize , uint4 code_key_)
{ return genericdb::Part_IdxCode_pattern_search (t,c, allocated_pattern, memsize, code_key_); 
}

inline  MCO_RET Part::IdxCode::pattern_next ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern )
{ return genericdb::Part_IdxCode_pattern_next (t, c, allocated_pattern); 
}

inline  MCO_RET Part::IdxCode::locate(mco_trans_h t, /*OUT*/ mco_cursor_h c, Part & handle)
{ return genericdb::Part_IdxCode_locate(t, c, &handle ); 
}

inline  MCO_RET Part::IdxCode::find( mco_trans_h t_, uint4 code_key_, /*OUT*/ Part & handle_) 
{ MCO_RET ret_ = genericdb::Part_IdxCode_find(t_, code_key_, &handle_ ); handle_.set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET Part2::create( mco_trans_h t )
{ MCO_RET ret_ = genericdb::Part2_new(t,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET Part2::remove()
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::Part2_delete(this)); 
}

inline  MCO_RET Part2::remove_all( mco_trans_h t )
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::Part2_delete_all(t)); 
}

inline  MCO_RET Part2::checkpoint()
{ MCO_RET ret_=genericdb::Part2_checkpoint(this); return ret_;
}

inline  MCO_RET Part2::broker_id_get ( int4 & result )
{ MCO_RET ret_ = genericdb::Part2_broker_id_get(this, &result); return ret_;
} 

inline  MCO_RET Part2::broker_id_put( int4 value )
{ MCO_RET ret_ = genericdb::Part2_broker_id_put(this, value); return ret_; 
} 

inline  MCO_RET Part2::password_get(char * dest, uint2 dest_size)
{ MCO_RET ret_ = genericdb::Part2_password_get(this,dest,dest_size); return ret_; 
}

inline  MCO_RET Part2::password_put( const char * src, uint2 len )
{ MCO_RET ret_ = genericdb::Part2_password_put(this,src, len); return ret_; 
}

inline  MCO_RET Part2::user_id_get ( uint4 & result )
{ MCO_RET ret_ = genericdb::Part2_user_id_get(this, &result); return ret_;
} 

inline  MCO_RET Part2::user_id_put( uint4 value )
{ MCO_RET ret_ = genericdb::Part2_user_id_put(this, value); return ret_; 
} 

inline  MCO_RET Part2::from_cursor( mco_trans_h t, mco_cursor_h c )
{ MCO_RET ret_ = genericdb::Part2_from_cursor(t,c,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET Part2::IdxCode::cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c )
{ return genericdb::Part2_IdxCode_index_cursor(t,c); 
}

inline  MCO_RET Part2::IdxCode::search( mco_trans_h t_, mco_cursor_h c_, MCO_OPCODE op_, uint4 user_id_key_ ) 
{ return genericdb::Part2_IdxCode_search(t_,c_,op_, user_id_key_); 
}

inline  MCO_RET Part2::IdxCode::compare( mco_trans_h t_, mco_cursor_h c_, uint4 user_id_key_, int & result_ ) 
{ return genericdb::Part2_IdxCode_compare(t_,c_, user_id_key_, &result_); 
}

inline  MCO_RET Part2::IdxCode::pattern_size( uint4 user_id_key_, /*OUT*/ uint4 *size_) 
{ return genericdb::Part2_IdxCode_pattern_size( user_id_key_, size_); 
}

inline  MCO_RET Part2::IdxCode::pattern_search ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern, mco_size_t memsize , uint4 user_id_key_)
{ return genericdb::Part2_IdxCode_pattern_search (t,c, allocated_pattern, memsize, user_id_key_); 
}

inline  MCO_RET Part2::IdxCode::pattern_next ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern )
{ return genericdb::Part2_IdxCode_pattern_next (t, c, allocated_pattern); 
}

inline  MCO_RET Part2::IdxCode::locate(mco_trans_h t, /*OUT*/ mco_cursor_h c, Part2 & handle)
{ return genericdb::Part2_IdxCode_locate(t, c, &handle ); 
}

inline  MCO_RET Part2::IdxCode::find( mco_trans_h t_, uint4 user_id_key_, /*OUT*/ Part2 & handle_) 
{ MCO_RET ret_ = genericdb::Part2_IdxCode_find(t_, user_id_key_, &handle_ ); handle_.set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET User::create( mco_trans_h t )
{ MCO_RET ret_ = genericdb::User_new(t,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET User::remove()
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::User_delete(this)); 
}

inline  MCO_RET User::remove_all( mco_trans_h t )
{ MCO_RET ret_; set_valid(false); return (ret_=genericdb::User_delete_all(t)); 
}

inline  MCO_RET User::checkpoint()
{ MCO_RET ret_=genericdb::User_checkpoint(this); return ret_;
}

inline  MCO_RET User::broker_id_get ( int4 & result )
{ MCO_RET ret_ = genericdb::User_broker_id_get(this, &result); return ret_;
} 

inline  MCO_RET User::broker_id_put( int4 value )
{ MCO_RET ret_ = genericdb::User_broker_id_put(this, value); return ret_; 
} 

inline  MCO_RET User::user_id_get ( uint4 & result )
{ MCO_RET ret_ = genericdb::User_user_id_get(this, &result); return ret_;
} 

inline  MCO_RET User::user_id_put( uint4 value )
{ MCO_RET ret_ = genericdb::User_user_id_put(this, value); return ret_; 
} 

inline  MCO_RET User::password_get(char * dest, uint2 dest_size)
{ MCO_RET ret_ = genericdb::User_password_get(this,dest,dest_size); return ret_; 
}

inline  MCO_RET User::password_put( const char * src, uint2 len )
{ MCO_RET ret_ = genericdb::User_password_put(this,src, len); return ret_; 
}

inline  MCO_RET User::from_cursor( mco_trans_h t, mco_cursor_h c )
{ MCO_RET ret_ = genericdb::User_from_cursor(t,c,this); set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET User::idx_user_id::cursor( mco_trans_h t, /*OUT*/ mco_cursor_h c )
{ return genericdb::User_idx_user_id_index_cursor(t,c); 
}

inline  MCO_RET User::idx_user_id::search( mco_trans_h t_, mco_cursor_h c_, MCO_OPCODE op_, uint4 user_id_key_ ) 
{ return genericdb::User_idx_user_id_search(t_,c_,op_, user_id_key_); 
}

inline  MCO_RET User::idx_user_id::compare( mco_trans_h t_, mco_cursor_h c_, uint4 user_id_key_, int & result_ ) 
{ return genericdb::User_idx_user_id_compare(t_,c_, user_id_key_, &result_); 
}

inline  MCO_RET User::idx_user_id::pattern_size( uint4 user_id_key_, /*OUT*/ uint4 *size_) 
{ return genericdb::User_idx_user_id_pattern_size( user_id_key_, size_); 
}

inline  MCO_RET User::idx_user_id::pattern_search ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern, mco_size_t memsize , uint4 user_id_key_)
{ return genericdb::User_idx_user_id_pattern_search (t,c, allocated_pattern, memsize, user_id_key_); 
}

inline  MCO_RET User::idx_user_id::pattern_next ( mco_trans_h t, mco_cursor_h c, void *allocated_pattern )
{ return genericdb::User_idx_user_id_pattern_next (t, c, allocated_pattern); 
}

inline  MCO_RET User::idx_user_id::locate(mco_trans_h t, /*OUT*/ mco_cursor_h c, User & handle)
{ return genericdb::User_idx_user_id_locate(t, c, &handle ); 
}

inline  MCO_RET User::idx_user_id::find( mco_trans_h t_, uint4 user_id_key_, /*OUT*/ User & handle_) 
{ MCO_RET ret_ = genericdb::User_idx_user_id_find(t_, user_id_key_, &handle_ ); handle_.set_valid(ret_==MCO_S_OK); return ret_; 
}

inline  MCO_RET Dimensions::width_get ( float & result )
{ MCO_RET ret_ = genericdb::Dimensions_width_get(this, &result); return ret_;
} 

inline  MCO_RET Dimensions::width_put( float value )
{ MCO_RET ret_ = genericdb::Dimensions_width_put(this, value); return ret_; 
} 

inline  MCO_RET Dimensions::length_get ( float & result )
{ MCO_RET ret_ = genericdb::Dimensions_length_get(this, &result); return ret_;
} 

inline  MCO_RET Dimensions::length_put( float value )
{ MCO_RET ret_ = genericdb::Dimensions_length_put(this, value); return ret_; 
} 

inline  MCO_RET Dimensions::height_get ( float & result )
{ MCO_RET ret_ = genericdb::Dimensions_height_get(this, &result); return ret_;
} 

inline  MCO_RET Dimensions::height_put( float value )
{ MCO_RET ret_ = genericdb::Dimensions_height_put(this, value); return ret_; 
} 




} // namespace genericdb

#endif
